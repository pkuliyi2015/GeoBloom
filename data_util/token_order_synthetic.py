'''
The following code is generated by GPT-4o website.
'''


import os
import random

random.seed(0)
# Categories for POIs
categories = [
    "Bakery",
    "Cafe",
    "Restaurant",
    "Hotel",
    "Bookstore",
    "Gym",
    "Pharmacy",
    "Supermarket",
    "Library",
    "Cinema",
    "Museum",
    "Bar",
    "Nightclub",
    "Spa",
    "Beauty Salon",
    "Park",
    "Zoo",
    "Amusement Park",
    "Shopping Mall",
    "Electronics Store",
    "Furniture Store",
    "Clothing Store",
    "Pet Store",
    "Gas Station",
    "Hospital",
    "Clinic",
    "School",
    "University",
    "Bank",
    "Post Office",
    "Police Station"
]


# Attributes that can be included or excluded
attributes = [
    "gluten-free options",
    "dairy products",
    "vegan options",
    "vegetarian meals",
    "meat dishes",
    "seafood",
    "alcoholic beverages",
    "live music",
    "outdoor seating",
    "indoor seating",
    "wifi",
    "parking",
    "air conditioning",
    "heating",
    "pet-friendly",
    "kids-friendly",
    "wheelchair accessible",
    "delivery service",
    "takeaway service",
    "buffet",
    "smoking area",
    "private rooms",
    "reservation required",
    "self-checkout",
    "drive-through",
    "24/7 service",
    "play area",
    "guided tours",
    "gift shop",
    "membership required",
    "personal trainer",
    "group classes",
    "happy hour",
    "karaoke",
    "pool table",
    "arcade games",
    "coupons available",
    "seasonal discounts",
    "free samples",
    "special events",
    "free parking",
    "valet parking",
    "electric vehicle charging",
    "onsite security",
    "first aid available",
    "ATM available"
]

# Generate random coordinates near a given point (in meters)
def random_coord_near(x, y, max_offset):
    return (
        round(x + random.uniform(-max_offset, max_offset), 2),
        round(y + random.uniform(-max_offset, max_offset), 2)
    )

# Generate POIs and queries with meaningful Cartesian locations
def generate_pois_and_queries(num_queries=1000, num_distractors=2):
    queries = []
    pois = []

    for i in range(num_queries):
        # Generate a query with a specific category and attributes
        category = random.choice(categories)
        num_included_attrs = random.randint(1, 3)
        query_included_attrs = random.sample(attributes, num_included_attrs)
        query_excluded_attrs = [attr for attr in attributes if attr not in query_included_attrs]
        query_excluded_attrs = random.sample(query_excluded_attrs, min(random.randint(1, len(query_excluded_attrs) - 1), 3))

        query_text = f"{category} with " + ' and '.join(query_included_attrs)
        query_text += f" but without {' and '.join(query_excluded_attrs)}"
        
        # shuffle the query_included_attrs and query_excluded_attrs
        random.shuffle(query_included_attrs)
        random.shuffle(query_excluded_attrs)

        # Central location for the query within a 10km x 10km area
        query_x = random.uniform(0, 10000)  # x in meters
        query_y = random.uniform(0, 10000)  # y in meters

        # Create a matching POI for the query, slightly farther than distractors (200-300 meters away)
        # It should contain all the attributes of the query, plus 0-2 additional attributes
        poi_included_attrs = query_included_attrs.copy()
        # num_extra_attrs = random.randint(0, 2)
        # if num_extra_attrs > 0:
        #     # Extra attributes should be different from the query attributes and not included in the query_excluded_attrs
        #     extra_attrs = [attr for attr in attributes if attr not in poi_included_attrs and attr not in query_excluded_attrs]
        #     poi_included_attrs.extend(random.sample(extra_attrs, num_extra_attrs))

        poi_excluded_attrs = None
        if random.random() < 0.5:
            # POI excluded attributes should be different from POI included attributes
            poi_excluded_attrs = [attr for attr in attributes if attr not in poi_included_attrs]
            poi_excluded_attrs = random.sample(poi_excluded_attrs, min(random.randint(1, len(poi_excluded_attrs) - 1), 2))

        poi_text = f"{category} with " + ' and '.join(poi_included_attrs)
        if poi_excluded_attrs:
            poi_text += f" but without {' and '.join(poi_excluded_attrs)}"
        
        # Place true POI within 200-300 meters of the query
        poi_x, poi_y = random_coord_near(query_x, query_y, max_offset=300)
        
        # Add POI to POIs list and set truth_id to its index
        truth_id = len(pois)
        pois.append((category, poi_included_attrs, poi_excluded_attrs, poi_text, poi_x, poi_y))
        
        # Add query with truth_id
        queries.append([query_text, query_x, query_y, truth_id])

        # Create distractor POIs (non-matches) closer to the query location (50-100 meters away)
        for _ in range(num_distractors):
            # Distractor POIs should have one of the following:
            # 1. It has one of the attributes that without in the query. 
            # 2. It lacks at least one attribute that is included in the query.
            # Other attributes are random.
            # We assign a 33% for 1, 33% for 2, 33% for both.
            pre_distractor_included_attrs = random.sample(query_excluded_attrs, random.randint(1, len(query_excluded_attrs)))
            pre_distractor_excluded_attrs = random.sample(query_included_attrs, random.randint(1, len(query_included_attrs)))

            if random.random() < 0.33:
                distractor_included_attrs = pre_distractor_included_attrs
                distractor_excluded_attrs = None
            elif random.random() < 0.66:
                distractor_included_attrs = None
                distractor_excluded_attrs = pre_distractor_excluded_attrs
            else:
                distractor_included_attrs = pre_distractor_included_attrs
                distractor_excluded_attrs = pre_distractor_excluded_attrs

            if not distractor_included_attrs:
                # If no included attributes, we add one attribute that is not in excluded_attrs
                distractor_included_attrs = [attr for attr in attributes if attr not in distractor_excluded_attrs]
                distractor_included_attrs = random.sample(distractor_included_attrs, random.randint(1, min(len(distractor_included_attrs) - 1, 2)))

            if not distractor_excluded_attrs:
                # If no excluded attributes, we add one attribute that is not in included_attrs
                distractor_excluded_attrs = [attr for attr in attributes if attr not in distractor_included_attrs]
                distractor_excluded_attrs = random.sample(distractor_excluded_attrs, random.randint(1, min(len(distractor_excluded_attrs) - 1, 2)))
            
            description = f"{category} with {' and '.join(distractor_included_attrs)}"
            description += f" but without {' and '.join(distractor_excluded_attrs)}"
            
            # Place distractor POI within 50-100 meters of the query
            distractor_x, distractor_y = random_coord_near(query_x, query_y, max_offset=100)
            pois.append((category, distractor_included_attrs, distractor_excluded_attrs, description, distractor_x, distractor_y))

    return queries, pois

# Write POIs to file (without POI ID)
def write_pois_to_file(pois, filename):
    with open(filename, "w", encoding='utf-8') as f:
        for category, included_attrs, excluded_attrs, description, x, y in pois:
            poi_text = f"{description}"
            f.write(f"{poi_text}\t{x}\t{y}\n")

# Write Queries to file
def write_queries_to_file(queries, filename):
    with open(filename, "w", encoding='utf-8') as f:
        for query_text, x, y, truth_id in queries:
            f.write(f"{query_text}\t{x}\t{y}\t{truth_id}\n")

if __name__ == "__main__":
    # Generate Queries and POIs with direct truth_id assignment
    num_queries = 1000
    queries, pois = generate_pois_and_queries(num_queries=num_queries, num_distractors=4)

    write_queries_to_file(queries, filename="data/Synthetic/queries.txt")
    # Shuffle queries
    random.shuffle(queries)

    # Split queries into train, dev, and test sets
    train_split = int(len(queries) * 0.7)
    dev_split = int(len(queries) * 0.8)

    train_queries = queries[:train_split]
    dev_queries = queries[train_split:dev_split]
    test_queries = queries[dev_split:]

    # Write to files
    os.makedirs('data/Synthetic', exist_ok=True)
    write_queries_to_file(train_queries, filename="data/Synthetic/train.txt")
    write_queries_to_file(dev_queries, filename="data/Synthetic/dev.txt")
    write_queries_to_file(test_queries, filename="data/Synthetic/test.txt")
    write_pois_to_file(pois, filename="data/Synthetic/poi.txt")

    print(f"Generated {len(queries)} queries and {len(pois)} POIs.")
    print(f"Train set: {len(train_queries)} queries, Dev set: {len(dev_queries)} queries, Test set: {len(test_queries)} queries.")
